# 研究文档：绩效数据同步功能

**版本:** 1.0  
**日期:** 2025-12-27  
**状态:** 已完成

---

## 目的

本文档记录绩效数据同步功能的技术选型、设计决策和研究发现。

---

## 技术选型

### 1. API 接口设计

**决策:** 使用 RESTful API 设计

**理由:**

- 与现有系统保持一致（员工、组织、职务数据都使用 RESTful API）
- RESTful API 简单直观，易于理解和维护
- 支持标准的 HTTP 方法（GET、POST）

**替代方案考虑:**

- GraphQL：功能更强大，但增加了复杂度，当前需求不需要
- gRPC：性能更好，但需要额外的工具支持，当前需求不需要

### 2. 数据同步方式

**决策:** 支持增量同步和全量同步

**理由:**

- 增量同步：减少数据传输量，提高同步效率
- 全量同步：确保数据完整性，适用于首次同步或数据修复
- 两种方式结合使用，满足不同场景需求

**实现方式:**

- 增量同步：基于 `last_synced_at` 字段判断变更
- 全量同步：同步所有数据，覆盖现有数据

### 3. 状态管理

**决策:** 使用 Pinia Store 管理绩效数据状态

**理由:**

- 符合项目宪法要求（Principle 3: Centralized State Management）
- 与现有模块保持一致（员工、组织、职务都使用 Pinia Store）
- 提供类型安全的状态管理

**Store 结构:**

```typescript
interface PerformanceState {
  reports: PerformanceReport[]
  total: number
  loading: boolean
  filters: PerformanceReportFilters
  syncing: boolean
  syncStatus: 'idle' | 'syncing' | 'success' | 'failed'
}
```

### 4. 分页策略

**决策:** 使用服务端分页

**理由:**

- 绩效数据量可能很大，客户端分页不现实
- 服务端分页减少数据传输量，提高性能
- 与现有模块保持一致（员工、组织、职务都使用服务端分页）

**分页参数:**

- `page`: 页码（从1开始）
- `pageSize`: 每页条数（默认10）

### 5. 筛选策略

**决策:** 使用服务端筛选

**理由:**

- 数据量大，客户端筛选性能差
- 服务端筛选减少数据传输量
- 支持复杂的筛选条件组合

**筛选参数:**

- `year`: 年份筛选
- `quarter`: 季度筛选
- `employee_name`: 员工姓名搜索（模糊匹配）
- `employee_user_id`: 员工用户ID搜索（精确匹配）
- `organization_path_ids`: 组织路径ID筛选
- `performance_rating`: 绩效评级筛选

### 6. 同步状态管理

**决策:** 使用轮询方式检查同步状态

**理由:**

- 后端 API 支持通过 batch_id 查询同步状态
- 轮询方式简单可靠，不需要额外的 WebSocket 支持
- 与现有同步模块保持一致

**实现方式:**

- 触发同步后，返回 batch_id
- 定期轮询同步状态（如每5秒）
- 同步完成后停止轮询

**未来优化:**

- 如果后端支持 WebSocket，可以改为实时推送

### 7. 错误处理

**决策:** 使用 Sentry 记录错误，ElMessage 显示用户提示

**理由:**

- 符合项目宪法要求（Principle 5: Production Observability）
- 与现有模块保持一致
- 提供完整的错误追踪和用户友好的错误提示

**实现方式:**

```typescript
try {
  await performanceStore.fetchReports()
} catch (error) {
  Sentry.captureException(error, {
    tags: { module: 'performance' },
    extra: { filters: performanceStore.filters }
  })
  ElMessage.error('加载绩效数据失败，请稍后重试')
}
```

### 8. 数据转换

**决策:** 后端使用 snake_case，前端使用 camelCase

**理由:**

- 后端 API 返回字段使用 snake_case（如 `batch_id`）
- 前端 TypeScript 代码使用 camelCase（如 `batchId`）
- 需要数据转换层

**实现方式:**

- 使用 `transform` 工具函数转换数据
- 与现有模块保持一致

---

## 设计决策

### 1. 数据源管理

**决策:** 初期不实现数据源管理界面

**理由:**

- 数据源配置由后端管理，前端仅展示状态
- 减少初期开发工作量
- 后续可以根据需求扩展

### 2. 定时同步配置

**决策:** 初期不实现定时同步配置界面

**理由:**

- 定时同步由后端管理，前端仅支持手动触发
- 减少初期开发工作量
- 后续可以根据需求扩展

### 3. 绩效数据可视化

**决策:** 不包含在本次功能范围内

**理由:**

- 绩效数据可视化由其他功能模块提供
- 本次功能仅负责数据同步和列表展示

### 4. 数据编辑

**决策:** 不支持前端编辑绩效数据

**理由:**

- 绩效数据以源系统为准，前端仅负责展示
- 避免数据不一致问题

---

## 性能优化

### 1. 分页加载

- 使用服务端分页，限制单次请求数据量
- 默认每页 10 条，可以根据需要调整

### 2. 防抖处理

- 搜索输入框使用防抖，避免频繁请求
- 筛选条件变更时使用防抖，减少请求次数

### 3. 数据缓存

- 使用 Pinia Store 缓存数据，避免重复请求
- 筛选条件或分页变更时才重新请求

### 4. 虚拟滚动（未来）

- 如果数据量很大，可以考虑使用虚拟滚动
- 当前使用分页，暂不需要虚拟滚动

---

## 测试策略

### 1. 单元测试

- **目标:** 80%+ 覆盖率
- **重点:** Store actions、数据转换、验证逻辑
- **工具:** Vitest

### 2. E2E 测试

- **目标:** 覆盖主要用户流程
- **重点:** 列表加载、筛选、同步触发
- **工具:** Playwright

---

## 风险评估

### 1. API 接口变更

**风险:** 后端 API 接口可能变更

**缓解:**

- 使用 TypeScript 接口定义，类型检查可提前发现问题
- 保持与后端开发团队沟通

### 2. 大数据量性能问题

**风险:** 数据量大时，列表加载可能较慢

**缓解:**

- 使用分页加载，限制单页数据量
- 添加加载状态提示
- 未来可以考虑虚拟滚动

### 3. 同步状态实时更新

**风险:** 轮询方式可能不够实时

**缓解:**

- 使用合理的轮询间隔（如5秒）
- 未来如果后端支持 WebSocket，可以改为实时推送

---

## 未来扩展

### 1. 数据源管理界面

- 展示数据源列表
- 配置数据源连接
- 测试数据源连接

### 2. 定时同步配置界面

- 配置同步计划
- 启用/禁用定时同步
- 查看同步历史

### 3. 数据导出

- 导出 Excel
- 导出 CSV
- 支持筛选条件导出

### 4. 高级筛选

- 多条件组合筛选
- 保存筛选条件
- 筛选条件模板

### 5. 实时同步状态

- WebSocket 实时推送
- 同步进度条
- 同步详情展示

---

## 总结

本次功能实现遵循项目宪法要求，使用成熟的技术方案，与现有模块保持一致。重点关注数据同步和列表展示功能，为后续扩展预留空间。
